close allclear allclcpar.f1=43.3;par.g1=10;par.g2=209;par.h=1;par.num = 100; % number of space points% initial conditionsx0 = linspace(-1,3,par.num);n0 = f(x0,par)./(f(x0,par) + g(x0,par));y0 = [x0 n0];nump = 250;output_times = linspace(0,0.4,nump);  % to make the curves for a constant v% integrate the odes, one for each x point[tout,yout]=ode45(@(t,y)derivs(t,y,par),output_times,y0);% All the real work is done now. The rest is just plotting the output.figure(1)for i=1:nump    tt(i,:) = tout(i)*ones(1,par.num); % has to be a better way to do this. I'm too lazy.    plot3(yout(i,1:par.num),tt(i,:),yout(i,par.num+1:2*par.num))    hold onendhold off% Put the data into long vectors for use by the delaunay triangulationxx = reshape(yout(:,1:par.num),1,[]);nn = reshape(yout(:,par.num+1:2*par.num),1,[]);tt = reshape(tt,1,[]);tri = delaunay(xx,tt);figure(2)trisurf(tri, xx, tt, nn);%% ------------------------------------------------% RHS of odefunction out = derivs(t,y,par)x = y(1:par.num);n = y(par.num+1:2*par.num);out(1:par.num) = -v(t);out(par.num+1:2*par.num) = (1-n).*f(x,par) - n.*g(x,par);out = out';end%% ------------function out = f(x,par)out = 0 + (x>0 & x<1).*(par.f1*x);endfunction out = g(x,par)out = par.g2*(x<=0) + par.g1*x.*(x>0);endfunction out = v(t)out = 50*sin(50*t);  end