 %  ------------------------------------------------------------------- %   This is a simple ode integrator for the reduced HH equations (also called%   the fast-slow HH equations). It uses a manual bisection method to plot%   the nullclines, just for fun. It would be faster and more efficient to use%   a nonlinear solver to do this, but then you would miss out on all the fun%   of writing a bisection method.%   For Chapter 5, Fig. 5.10 of%   Keener and Sneyd, Mathematical Physiology, 3rd Edition, Springer.% %   Written by James Keener and James Sneyd% %  ------------------------------------------------------------------- clear allclose allclcglobal gnabar gkbar gl vna vk vl Iapp rn0 vset(0,                           ...   'defaultaxesfontsize', 20,   ...   'defaultaxeslinewidth', 2, ...   'defaultlinelinewidth', 2.0);    % set parametersVeq = -65; % is the physiological  resting potential Tmin = -273.15;  % absolute zero temperatureTemp = 6.3; %the temperature for the original HH model  VNa = 50; % the sodium Nernst potentialVK = -77;  % the potassium Nernst potentialVL = -54.4;  % the leak Nernst potentialTfact=(Temp-Tmin)/(6.3-Tmin);% temperature correction factor for Nernst potentials%the driving force for the currents are the Nernst potentials shifted by Veq vna = Tfact*VNa - Veq; vk = Tfact*VK- Veq; vl = Tfact*VL - Veq;% the conductancesgnabar = 120.;gkbar = 36;gl = 0.3;rn0 = 0.8;% pick a value of Iapp Iapp = 50;  % with this value there are oscillationsIapp = 0;% first find the v nullcline by bisectionvlist = [vk+.01:1.1001:vna-0.03];% list of v values to use; avoid exactly Vk and exactly Vna[n0 ninf]=get_nullclines(vlist); % now integrate the differential equationststep = 0.02;if(Iapp==0)    t_end=20;    v0 = 7; % give a small initial stimulus away from zero    h0 = 0.3177;else     t_end=40;    v0 = 14;       h0 = 0.515;end tspan = [0:tstep:t_end];s0 = [v0;h0];  % initial values[T,S] = ode23(@deRHS,tspan, s0, odeset('maxstep',1));  v = S(:,1);h = S(:,2);formatSpecF = '%5.2f\n';% plot v vs tfigure(1)plot(T,v)xlabel('Time (ms)')ylabel('v (mV)')title(strcat('I_{app}= ',sprintf(formatSpecF,Iapp)),'fontsize',18)% the phase portraithold onfigure(2)plot(vlist,n0,'g--',vlist,ninf,'b--',v ,h,'r','linewidth',2)  xlabel('v (mV)')ylabel('n')title(strcat('I_{app}= ',sprintf(formatSpecF,Iapp)),'fontsize',18)legend('dv/dt=0','dn/dt=0')hold onend%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% the right hand side for ode simulation:function s_prime=deRHS(t,s)global gnabar gkbar gl vna vk vl Iapp BCL rn0v = s(1);n = s(2);% If there is a stimulus, add itIstimut = (BCL>0)*Iapp/cosh(mod(t,BCL)-BCL/4) + (BCL==0)*Iapp; Gt= gate_de(v);AM=Gt(1);BM = Gt(2);AN = Gt(3);BN = Gt(4); h = rn0 - n;aminf = AM/(AM+BM); Ina = gnabar*aminf.^3.*h.*(v-vna) ;Ik = gkbar*n.^4*(v-vk);Icl = gl*(v-vl);      Fv = -Ina-Ik-Icl;Fw=AN*(1.-n)-BN*n;s_prime = [Fv+Istimut Fw]';end%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function [n0,ninf]= get_nullclines(vlist)global v   % for each v find f(v,n) = 0 by bisection  for j = 1:length(vlist)    v=vlist(j);  % guess a lower bound a = 0;% guess an upper boundb = 1;%this is the answer - call the function bisect(a,b,@fval)n0(j)= bisect(a,b,@feval); Gt= gate_de(v);AN = Gt(3);BN = Gt(4);ninf(j) = AN/(AN+BN); endend %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function fn = feval(n)global v% evaluate the function s=[v,n]; t=0;fhh= deRHS(t,s);  % use the rhs of the defn=fhh(1);end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function gate = gate_de(v) % calculate the gating functions for V                 AM=.1*(25.-v)./(exp(2.5 -0.1*v)-1.);BM=4.*exp(-v/18.);AN=.01*(10.-v)./(exp(1.-0.1*v)-1.);BN=.125*exp(-v/80.);gate = [AM BM AN BN];end%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function root = bisect(a,b,feval)ul = a;fl = feval(ul);uu = b;fu = feval(uu);% we make the assumption, without checking, that % fu*fl<0% if not, the algoritm fails to find a root.N = 20;  % number of iterates% the main bisection algorithmfor j = 1:Nuc = (ul+uu)/2;fc = feval(uc);ftest = (fc.*fl>0);ul = ftest.*uc+(1-ftest).*ul;fl = ftest.*fc + (1-ftest).*fl;uu = (1-ftest).*uc+ ftest.*uu;fu = (1-ftest).*fc + ftest.*fu;endroot = uc;end 