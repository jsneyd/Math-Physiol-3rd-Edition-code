% Here we plot the nullclines for the rHH equations for several values of% Iapp function rHH_solverglobal gnabar gkbar gl Vna Vk Vl Iapp    BCL rn0 Vset(0,                           ...   'defaultaxesfontsize', 20,   ...   'defaultaxeslinewidth', 2, ...   'defaultlinelinewidth', 2.0);   %parametersgnabar = 120.;gkbar = 36;gl = 0.3;Vna = 115;Vk = -12;Vl = 10.5988;rn0 = 0.8;%rn0 = 0.9;% pick a value of Iapp Iplist=[0,50,120];colorlist=['b','g','m'];for j = 1:length(Iplist)    Iapp = Iplist(j); %  find the v nullcline by bisectionvlist = [Vk+.01:1.1001:Vna-0.03];% list of V values to use; avoid exactly Vk and exactly Vna[n0 ninf]=get_nullclines(vlist);  formatSpecF = '%5.2f\n'; % the phase portraitfigure(1)plot(vlist,n0, colorlist(j),vlist,ninf,'r', 'linewidth',2)  xlabel('v (mV)')ylabel('n')hold onendfigure(1)text(72,0.9,'dn/dt=0','fontsize',18)text(72,0.73,'dV/dt=0','fontsize',18)text(8.5,0.3,'I_{app}=0','fontsize',18)text(22,0.45,'I_{app}=50','fontsize',18)text( 0,0.8,'I_{app}=120','fontsize',18)annotation('textarrow',[.33,.27],[.5,.55])hold off%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%the right hand side for ode simulation:function s_prime=deRHS(t,s)global gnabar gkbar gl Vna Vk Vl Iapp BCL rn0V = s(1);W = s(2);% If there is a stimulus, add itIstimut = (BCL>0)*Iapp/cosh(mod(t,BCL)-BCL/4) + (BCL==0)*Iapp;n = W;Gt= gate_de(V);AM=Gt(1);BM = Gt(2);AN = Gt(3);BN = Gt(4); h = rn0 - n;aminf = AM/(AM+BM); Ina = gnabar*aminf.^3.*h.*(V-Vna) ;Ik = gkbar*n.^4*(V-Vk);Icl = gl*(V-Vl);      Fv = -Ina-Ik-Icl;Fw=AN*(1.-n)-BN*n;s_prime = [Fv+Istimut Fw]';%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function [n0,ninf]= get_nullclines(vlist)global V   % for each v find f(v,n) = 0 by bisection  for j = 1:length(vlist)    V=vlist(j);  % guess a lower bound a = 0;% guess an upper boundb = 1;%this is the answer - call the function bisect(a,b,@fval)n0(j)= bisect(a,b,@feval); Gt= gate_de(V);AN = Gt(3);BN = Gt(4);ninf(j) = AN/(AN+BN);    end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function fn = feval(n)global V% evaluate the function s=[V,n]; t=0;fhh= deRHS(t,s);  % use the rhs of the defn=fhh(1); %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function gate = gate_de(V) % calculate the gating functions for V                 AM=.1*(25.-V)./(exp(2.5 -0.1*V)-1.);BM=4.*exp(-V/18.);AN=.01*(10.-V)./(exp(1.-0.1*V)-1.);BN=.125*exp(-V/80.);gate = [AM BM AN BN];%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function root = bisect(a,b,feval)ul = a;fl = feval(ul);uu = b;fu = feval(uu);% we make the assumption, without checking, that % fu*fl<0% if not, the algoritm fails to find a root.N = 20;  % number of iterates% the main bisection algorithmfor j = 1:Nuc = (ul+uu)/2;fc = feval(uc);ftest = (fc.*fl>0);ul = ftest.*uc+(1-ftest).*ul;fl = ftest.*fc + (1-ftest).*fl;uu = (1-ftest).*uc+ ftest.*uu;fu = (1-ftest).*fc + ftest.*fu;endroot = uc; 