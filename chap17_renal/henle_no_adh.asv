% this is an attempt to solve the nephron equations for loop of Henle
clear all; close all; clc;
set(0,                           ...
   'defaultaxesfontsize', 20,   ...
   'defaultaxeslinewidth', 2.0, ...
   'defaultlinelinewidth', 2.0);
% parameters
p.P = 0.9;
p.DPd = 0.15;
p.DPc = 0.22;
p.Hd = 0.1;
p.rd = 0.15;
p.Ka = 0.1;

p.N=51; % number of grid points
p.y = linspace(0,1,p.N);
 

onebyrclist = [0,0.5];
 
% make up some initial guess
Qa = -.5;
Qd = -Qa*p.y +(1-p.y);
Sd=-(Qd -1)*(p.rd*p.Hd)+1-p.DPd*p.Hd*p.y ; 
 
 X0=[Sd, Qa ];
 
[U]=fsolve(@(x)des(x,p),X0); 
Sd = U(1:p.N);
 
Qa = U(p.N+1);
 
Sd = U(1:p.N);
Qa = U(p.N+1);
[Qd,Qs,Sd,Sa,Ss,Cd,Ca,Cs]=get_fs(U, p);
 
 
figure(1)
 
plot(p.y,Qd,'--')
hold on 
 
xlabel('y')
ylabel('Relative Flux, Q_d')
 
box off
 
figure(2)
 
plot(p.y,Ca,p.y,Cd)
%text(0.09,1.65,'C_d','fontsize',18)
%text(0.18,1 ,'C_a','fontsize',18)
legend('boxoff')
legend('C_a','C_d','location','northwest') 
xlabel('y')
ylabel('Relative Concentration')
box off
 
%now loop on P for no ADH case:
% make up an initial guess
Qa = -.5;
Qd = -Qa*p.y +(1-p.y);
Sd=-(Qd -1)*(p.rd*p.Hd)+1-p.DPd*p.Hd*p.y ; 
 
 
 X0=[Sd, Qa];
Plist = [0.01:.01:1];
  
for j = 1:length(Plist)
    p.P = Plist(j);
 
[U]=fsolve(@(x)des(x,p),X0); 
% use the solution as the initial guess for the next try
X0=U;
Sd = U(1:p.N);
Qa = U(p.N+1);
[Qd,Qs,Sd,Sa,Ss,Cd,Ca,Cs]=get_fs(U, p);
 
 
QdP(j) = Qd(p.N);
 Ca0(j) = Ca(1);
Cd1(j) = Cd(p.N);
end
figure(3)
plot(Plist,Ca0,Plist,QdP, Plist,Cd1)
xlabel('P')
%axis([0 1 0 1.3])
%text(0.8,.8,'C_a(0)','fontsize',18)
%text(0.6,0.5,'Q_d(1)','fontsize',18)
legend('C_a(0)','Q_d(1)','C_d(1)','location','northwest')

function out = des(U,p)
 
 
dy = p.y(2)-p.y(1);
Sd = U(1:p.N);
Qa = U(p.N+1);
[Qd,Qs,Sd,Sa,Ss,Cd,Ca,Cs]=get_fs(U ,p);
 
 
Fd = Ss./Qs-Sd./Qd;
 
eqSd =[Sd(1)-1,(Sd(2:p.N-1)-Sd(1:p.N-2))/(dy)-p.Hd*Fd(1:p.N-2), ...
    (Sd(p.N)-Sd( p.N-1))/(dy)-p.Hd*Fd(p.N-1)];  
%  
eqQa = Sd(p.N)-1-(Qa+1)*p.rd*p.Hd+p.DPd*p.Hd;

out = [eqSd, eqQa ];

end

function [Qd,Qs,Sd,Sa,Ss,Cd,Ca,Cs]= get_fs(U, p)
Sd = U(1:p.N);
Qa = U(p.N+1);
 
tm = (1-Sd-p.DPd*p.Hd*p.y)/(p.rd*p.Hd);
Qd = 1+ tm;
Qs=-Qd-Qa;
Cd=Sd./Qd;
%Ca=Cd(p.N)-p.P*(p.y-1)/Qa;
 % using a Na-dependent ATPase:
 %Ca = Cd(p.N)*sqrt(2*Qa./(p.P*Cd(p.N)^2.*(p.y-1)+2*Qa));
 CaL=Cd(p.N);
   Ca0=-( -CaL+p.P*(p.y-1)/Qa);
 X0=CaL*ones(1,p.N);
 %Ca = bisect(@(x)Ca_eval(x,p,Qa,CaL),zeros(1,p.N),CaL*ones(1,p.N) );
 Ca = fsolve(@(x)Ca_eval(x,p,Qa,CaL), CaL*ones(1,p.N) );
Sa =Qa*Ca;
Ss = -Sa -Sd;
Cs=Ss./Qs;
 
end
 

    function out = Ca_eval(Ca,p,Qa,CaL)
        out = -2*p.Ka^3+Ca.^3+Ca.^2.*(2*p.Ka^3/CaL^2-CaL+p.P*(p.y-1)/Qa);
    end
% this code finds roots of functions using bisection
 
function root = bisect(feval, a,b)

ul = a;
fl = feval(ul);
uu = b;
fu = feval(uu);

% we make the assumption, without checking, that 
% fu*fl<0

% if not, the algoritm fails to find a root.

N = 20;  % number of iterates
% the main bisection algorithm
for j = 1:N
uc = (ul+uu)/2;
fc = feval(uc);
ftest = (fc.*fl>0);
ul = ftest.*uc+(1-ftest).*ul;
fl = ftest.*fc + (1-ftest).*fl;

uu = (1-ftest).*uc+ ftest.*uu;
fu = (1-ftest).*fc + ftest.*fu;
end
root = uc;

end